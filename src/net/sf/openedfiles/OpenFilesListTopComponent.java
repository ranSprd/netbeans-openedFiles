/*
 * Copyright (c) 2008, R.Nagel <kiar@users.sourceforge.net>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice, 
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright 
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the author nor the names of its contributors
 *       may be used to endorse or promote products derived from this
 *       software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT 
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 * SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * Contributor(s):
 * 
 */

// created by : R.Nagel <kiar@users.sourceforge.net>, 07.03.2008
//
// function   : main component of the module, contains a list of all opened 
//              files (editor)
//
// todo       :
//
// modified   : 

package net.sf.openedfiles;

import net.sf.openedfiles.actions.AbstractListPopupAction;
import net.sf.openedfiles.actions.BringToFrontAction;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import org.openide.util.ImageUtilities;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
import org.openide.windows.Mode;

/**
 * Top component which displays something.
 */
final class OpenFilesListTopComponent extends TopComponent 
        implements ActionListener, UpdateListener
{
  private OpenedFilesListener listener = new OpenedFilesListener() ;

  private static OpenFilesListTopComponent instance;
  
  private ListPopup popup ;
  
  /** path to the icon used by the component and its open action */
  static final String ICON_PATH = "resource/windowlist16.png";
  static final String LARGE_ICON_PATH = "resource/windowlist32.png";
  private static final String PREFERRED_ID = "OpenFilesListTopComponent";

  private OpenFilesListTopComponent()
  {
    initComponents();
    setName(NbBundle.getMessage(OpenFilesListTopComponent.class, "CTL_OpenFilesListTopComponent"));
    setToolTipText(NbBundle.getMessage(OpenFilesListTopComponent.class, "HINT_OpenFilesListTopComponent"));
    setIcon(ImageUtilities.loadImage(ICON_PATH, true));

    jButton1.addActionListener(this);
    jList1.addMouseListener( new ListMouseHandler());
//    jList1.setCellRenderer(new OpenFilesListRenderer() );
    
  }
  

  public void actionPerformed(ActionEvent e)
  {
    listener.update();
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jToolBar1 = new javax.swing.JToolBar();
        jButton1 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jButton1.setIcon(new javax.swing.ImageIcon(getClass().getResource("/resource/reload.png"))); // NOI18N
        jButton1.setToolTipText("update view");
        jToolBar1.add(jButton1);

        jList1.setModel(listener.getModel());
        jList1.setSelectionModel(listener);
        jScrollPane1.setViewportView(jList1);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jToolBar1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(jToolBar1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JList jList1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JToolBar jToolBar1;
    // End of variables declaration//GEN-END:variables
  /**
   * Gets default instance. Do not use directly: reserved for *.settings files only,
   * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
   * To obtain the singleton instance, use {@link findInstance}.
   */
  public static synchronized OpenFilesListTopComponent getDefault()
  {
    if (instance == null)
    {
      instance = new OpenFilesListTopComponent();
    }
    return instance;
  }

  /**
   * Obtain the OpenFilesListTopComponent instance. Never call {@link #getDefault} directly!
   */
  public static synchronized OpenFilesListTopComponent findInstance()
  {
    TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
    if (win == null)
    {
      return getDefault();
    }
    if (win instanceof OpenFilesListTopComponent)
    {
      return (OpenFilesListTopComponent) win;
    }
    return getDefault();
  }

//  @Override
  public int getPersistenceType()
  {
//    return TopComponent.PERSISTENCE_ALWAYS;
    return TopComponent.PERSISTENCE_NEVER ;
  }

  @Override
  public void componentOpened()
  {
  // TODO add custom code on component opening
  }

  @Override
  public void componentClosed()
  {
  // TODO add custom code on component closing
  }


  @Override
  protected String preferredID()
  {
    return PREFERRED_ID;
  }
  
  /**
   * Allows the top component to specify a ui-list (with modes) which can be docked
   * by end user. Subclasses should override this method if they want to alter
   * docking policy of top component.
   * So for example, by returning empty list, top component refuses to be 
   * docked anywhere.
   * Default implementation allows docking anywhere by returning input list 
   * unchanged.
   * @param modes
   * @return
   */
    @Override
  public List<Mode> availableModes(List<Mode> modes)
  {
    if (modes != null)
    {
      int size = modes.size() ;
      if (size > 0)
      {
        ArrayList<Mode> back = new ArrayList<Mode>(size) ;
        for(Mode single : modes)
        {
          String name = single.getName() ;
          if (name != null)
          {
            // dock everywhere, except editor frame
            if (! "editor".equals(name))
            {
              back.add(single) ;
            }
          }
        }
      }
    }
    
    return null ;
  }
  
  // --------------------------------------------------------------------------
  // UpdateListener
  // --------------------------------------------------------------------------

  // Listupdate
  public void updateStarting()
  {
    jButton1.setEnabled(false);
    jList1.setEnabled(false);
  }

  // Listupdate
  public void updateFinished()
  {
    jButton1.setEnabled(true);
    jList1.setEnabled(true);
  }
  
  private void createPopup()
  {
    popup = new ListPopup(listener, OpenFilesListTopComponent.this) ;
    //try
    {
      AbstractListPopupAction action = new BringToFrontAction() ;
      action.register( popup ) ;
      popup.addSeparator() ;
      popup.loadActions() ; // read actions definied in layer.xml (OFL/Menus/Popup/)
    }
    //catch (Exception e) 
    {
    }
  }
  
  
  /** Double-Click listener/handler */
  private class ListMouseHandler extends MouseAdapter
  {
    @Override
    public void mouseClicked( MouseEvent event )
    {
      if (event.getButton() == MouseEvent.BUTTON3)
      {
        Point p = event.getPoint() ;
        int clickIndex = jList1.locationToIndex(p) ;
        int selectedIndex = jList1.getSelectedIndex() ;

//        if ((selectedIndex >= 0) || (clickIndex >= 0))
        // into the list area
        if (clickIndex >= 0)
        {
          // no selection or outside a selection
          if (!listener.isSelectedIndex(clickIndex))
          {
            listener.setSelectionInterval(clickIndex, clickIndex);
          }
          
          // create the popup and show
          if (popup == null)
          {
            createPopup();
          }
          popup.show(p, clickIndex, selectedIndex );
        }
      }  
      else 
      {
        if (event.getClickCount() > 1)
        {
          // bring the selected component to front
          listener.bringToFront( jList1.locationToIndex( event.getPoint() ) );
        }
      }
    }
  }
  
}
